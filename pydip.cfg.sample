# Example configuration file for PyDip, the Python Diplomacy program
# 
# This file may be saved as $HOME/.pydiprc, or as pydip.cfg in the
# current working directory; settings in the latter will override
# those in the former.
# 
# Lines starting with hash marks (#) or semicolons (;) are ignored,
# and may be used for comments.  In this sample file, semicolons are
# used to show the default setting for each option.
# 
# The sections are ordered in approximate likelihood of customization.


[game]
# Parameters to be sent in the HLO message.

# syntax level (integer)
# Syntax level of the game.
# Mostly determines what kind of press can be sent.
# See the message syntax document for more details.
;LVL = 0

# Move Time Limit (integer)
# Time limit for movement phases, in seconds.
# A setting of 0 disables movement time limits.
# The standard "real-time" setting is 600 (five minutes).
;MTL = 0

# Retreat Time Limit (integer)
# Time limit for retreat phases, in seconds.
# A setting of 0 disables retreat time limits.
# The standard "real-time" setting is 120 (two minutes).
;RTL = 0

# Build Time Limit (integer)
# Time limit for build phases, in seconds.
# A setting of 0 disables build time limits.
# The standard "real-time" setting is 180 (three minutes).
;BTL = 0

# Press Time Limit (integer)
# Time (in seconds) before movement deadlines to start blocking press.
# If there is no movement time limit, this has no effect;
# otherwise, if this is greater than or equal to MTL,
# press is entirely blocked in movement phases.
;PTL = 0

# No Press during Retreats (boolean)
# Whether press is blocked during retreat phases.
;NPR = no

# No Press during Builds (boolean)
# Whether press is blocked during build phases.
;NPB = no

# Deadline Stops on Disconnection (boolean)
# Whether time limits pause when a non-eliminated player disconnects.
# The standard "real-time" setting is yes.
;DSD = no

# Any Orders Allowed (boolean)
# Whether to accept any syntactically valid order, regardless of legality.
# This server is more permissive than David's in AOA games;
# the latter doesn't accept orders for non-existent or foreign units.
# See also DATC option 4.E.1, which only comes up in AOA games.
# The standard "real-time" setting is no.
;AOA = no

# Partial Draws Allowed (boolean)
# Whether to allow draws that don't include all survivors.
# When this is on, clients can specify powers to allow in the draw,
# and the server can specify the powers in a draw.
# Only available at syntax level 10 or above.
;PDA = no


[server]
# Options for server operation.

# randomize power assignments (boolean)
# Whether to assign players to powers randomly.
# If not true, powers are assigned in token order
# (usually alphabetical), to each player as it connects.
;shuffle = yes

# close on disconnect (boolean)
# Whether a game should end when a player disconnects.
# Useful for testing, but should *not* be on for human games.
;quit = no

# time allowed for vetos (integer)
# Time (in seconds) to wait for vetos before processing certain admin commands.
# Use 0 to disable vetos entirely.
;veto_time = 20

# allow takeovers (boolean)
# Whether IAM messages can take over non-abandoned powers.
# This can be disturbing to the original player, so use with care.
# However, it allows new players to take over bot positions,
# and prevents problems with an undetected nonresponsive client.
;takeovers = no

# show replaced powers in summary (boolean)
# Whether SMR messages should list players that have been replaced.
# If true, the original player will be listed first,
# with the year of replacement and their center count at that time,
# but only if the new player reports a different name and/or version.
;replaced = no

# minimum player count for bots (integer)
# Blocks the bot-starting admin commands, in favor of more individual players.
# Specifically, starting bots requires that at least this many players
# be connected from different IP addresses.
# Use 0 to always allow starting bots.
;bot_min = 0

# number of games (integer)
# Minimum number of games to play before server stops.
# Use 0 to prevent the server from shutting down automatically.
;games = 1

# default variant (string)
# The map to use for games not started with the "start <variant> game" command.
# This should be the variant's DAIDE name as specified in the variants file.
;variant = standard

# record completed games (boolean)
# Whether to save game logs to disk and delete them from memory.
# If this is on, games will be saved with a .dpp extension,
# in the directory indicated by log_path (below).
# However, the server will stop reporting them in game listings.
;log_games = no

# game log directory (file)
# The directory in which to save game logs.
;log_path = log/games

# send admin messages (boolean)
# Whether the server should broadcast admin messages.
# This includes server-generated and forwarded messages,
# but not individual responses to admin commands.
;snd_admin = no

# forward admin messages (boolean)
# Whether non-command admin messages from clients should be re-broadcast.
;fwd_admin = no

# accept admin commands (boolean)
# Whether the server should accept admin commands.
# These allow players to do things outside the scope of DAIDE syntax,
# such as pausing the game, starting bots, or booting each other.
;admin_cmd = no


[judge]
# Options for basic judge operation, including premature endings.

# total years before setting draw (integer)
# Maximum length of a game, in game years.
# Games exceeding this length will be declared DIAS draws.
# Values greater than 8191 might disable this, but could cause other problems.
;draw = 4000

# static years before setting draw (integer)
# Maximum number of years in which supply center counts do not change.
# Comparable to the 50-move rule in FIDE chess.
# After this many game years, the game will be declared a DIAS draw.
# Note that supply centers changing hands is not enough;
# at least one power must have a different total supply center count.
# Setting this higher than "total years before setting draw" will disable it.
;static = 1000

# years before variable end (integer)
# Parameter for David Norman's Variable-Length mix-in rule,
# documented at http://www.diplom.org/Zine/S1998R/Norman/VarLength.html
# After this many years, the winning condition will start to decrease.
# For David's suggested conditions, use 3 here.
;var_start = 5000

# length of variable end (integer)
# Parameter for David Norman's Variable-Length mix-in rule.
# This many years after starting to decrease the winning condition,
# it will stop decreasing and remain at its new low value.
# For David's suggested conditions, use 9 here.
# Setting this to 0 will disable the rule entirely.
;var_length = 0

# variation of variable end (number)
# Parameter for David Norman's Variable-Length mix-in rule.
# The number of centers by which to decrease the winning condition per year.
# For David's suggested conditions, use 1.55 here.
# Setting this to 0 will disable the rule entirely.
;variation = 1.55

# list draw parties in DIAS (boolean)
# Whether to list the countries participating in a draw even in non-PDA games.
# Doing so technically violates the syntax, but makes some clients easier.
;full_DRW = no

# publish order sets (boolean)
# Whether to send SET messages, listing orders actually given by each power.
# This message was rejected by the DAIDE community, after it was implemented.
# Advantage over ORD messages: It can represent *any* order,
# even those to non-existent or foreign units.
# Disadvantage: Doesn't list results, and may be large.
;send_SET = no

# publish individual orders (boolean)
# Whether to send ORD messages each turn, as required by DAIDE.
# Can slow down the game, particularly when syntax-checked by each client.
;send_ORD = yes


[clients]
# Options applicable for all PyDip clients.

# ratings ladder score file (file)
# The file in which to store scores generated by the Ladder observer.
;score_file = log/stats/ladder_scores

# invalid message response (string)
# How to react when a message fails a syntax check or results in an error.
# "close"  or "die":         Send a final message to the server, and stop
# "print"  or "warn":        Display a warning to the user
# "HUH"    or "complain":    Send an error message to the server
# "carp"   or "croak":       All three of the above
# "ignore" or anything else: None of the above
# The second option will also re-raise the error, if any.
;response = HUH

# validate incoming messages (boolean)
# Whether to validate messages received from the server.
# Turn this on when testing a server or to protect against garbage;
# however, doing so will slow down the game, particularly startup.
;validate = no

# confirm order submission (boolean)
# Whether to send admin messages reporting that orders have been sent.
# Useful for testing, but should *not* be on for human games.
;confirm = no


[network]
# Settings for the network (DCSP) layer.

# host (string)
# The name or IP address of the server.
# If blank, the server will listen on all possible addresses,
# and clients will connect to localhost.
;host = 

# port (integer)
# The port that the server listens on.
;port = 16713

# send unnecessary final messages (boolean)
# Whether to send FM after receiving EM or FM.
# The extra FM may be useful to terminate input loops,
# particularly when using threads, but the protocol prohibits it.
;echo_final = no

# send empty representation messages (boolean)
# Whether to send an empty RM for the standard map.
# The standard says yes, but that may be changed soon.
;null_rm = no


[main]
# Options used by the core program functionality.

# verbosity (integer)
# How much debug or logging information to display.
;verbosity = 1

# log_file (file)
# File in which to log output lines, instead of printing them.
;log_file = 

# idle timeout for server loop (integer)
# Default time (in seconds) to wait for select() or poll() system calls.
# Not used when any client or game has a time limit.
# Higher numbers waste less CPU time, up to a point,
# but may make the program less responsive to certain inputs.
;wait_time = 600

# idle timeout for busy loops (integer)
# Default time (in seconds) to sleep in potential busy loops.
# Higher numbers may waste less CPU time in certain situations,
# but will make the program less responsive to certain inputs.
;sleep_time = 1

# block_exceptions (boolean)
# Whether to block exceptions seen by the ThreadManager.
# When on, the program is more robust, but harder to debug.
;block_exceptions = yes

# autostart (list)
# A list of internal clients to start each game.
;autostart = 


[dumbbot]
# Weights and probabilities for David's Dumbbot algorithm.

# print_csv (boolean)
# Whether to print a statistics file every turn, with province values.
;print_csv = no

# spring attack (integer)
# Importance of attacking centres we don't own, in Spring
;proximity_spring_attack_weight = 700

# spring defence (integer)
# Importance of defending our own centres in Spring
;proximity_spring_defence_weight = 300

# fall attack (integer)
# Importance of attacking centres we don't own, in Fall
;proximity_fall_attack_weight = 600

# fall defence (integer)
# Importance of defending our own centres in Fall
;proximity_fall_defence_weight = 400

# spring proximity (list of integers)
# Importance of proximity[n] in Spring
;spring_proximity_weight = 100, 1000, 30, 10, 6, 5, 4, 3, 2, 1

# spring strength (integer)
# Importance of our attack strength on a province in Spring
;spring_strength_weight = 1000

# spring competition (integer)
# Importance of lack of competition for the province in Spring
;spring_competition_weight = 1000

# fall proximity (list of integers)
# Importance of proximity[n] in Fall
;fall_proximity_weight = 1000, 100, 30, 10, 6, 5, 4, 3, 2, 1

# fall strength (integer)
# Importance of our attack strength on a province in Fall
;fall_strength_weight = 1000

# fall competition (integer)
# Importance of lack of competition for the province in Fall
;fall_competition_weight = 1000

# unit attack (integer)
# Importance of attacking opposing units
;base_unit_weight = 0

# home vacation (integer)
# Importance of vacating unattacked home SCs
;home_vacation_weight = 0

# home attack (integer)
# Importance of attacking another power's home supply centers
;home_attack_weight = 1

# home defence (integer)
# Importance of defending or regaining our own home supply centers
;home_defence_weight = 1

# build defence (integer)
# Importance of building in provinces we need to defend
;build_defence_weight = 1000

# build proximity (list of integers)
# Importance of proximity[n] when building
;build_proximity_weight = 1000, 100, 30, 10, 6, 5, 4, 3, 2, 1

# remove defence (integer)
# Importance of removing in provinces we don't need to defend
;remove_defence_weight = 1000

# remove proximity (list of integers)
# Importance of proximity[n] when removing
;remove_proximity_weight = 1000, 100, 30, 10, 6, 5, 4, 3, 2, 1

# play alternative (integer)
# Percentage change of not automatically playing the best move
;play_alternative = 50

# alternative modifier (integer)
# If not automatic, chance of playing best move
# if inferior move is nearly as good.
# Larger numbers mean less chance.
;alternative_difference_modifier = 500

# square coefficient (integer)
# A in S = Ax^2 + Bx + C, where x is centre count and S is size of power
;size_square_coefficient = 1

# size coefficient (integer)
# B in S = Ax^2 + Bx + C, where x is centre count and S is size of power
;size_coefficient = 4

# size constant (integer)
# C in S = Ax^2 + Bx + C, where x is centre count and S is size of power
;size_constant = 16

# convoy weight (integer)
# Percentage value a convoy has compared to a comparable move.
# 0 prevents convoys; 100 gives them equal weight.
;convoy_weight = 0


[datc]
# Options from Lucas B. Kruijswijk's Diplomacy Adjudicator Test Cases:
# http://web.inter.nl.net/users/L.B.Kruijswijk/
# Not all options are supported; some cannot be, within DAIDE.
# Some options use letters not used by the DATC; in general,
# the syntax disallows the option entirely in these cases.

# multi-route convoy disruption (character)
# 4.A.1.  MULTI-ROUTE CONVOY DISRUPTION
# a: A convoy is disrupted when any possible route is disrupted.
# b: A convoy is disrupted when all possible routes are disrupted.
# c: Multi-route convoys are not allowed.
# DATC: b; DPTG: a; DAIDE: c
;datc_4a1 = b

# convoy disruption paradoxes (character)
# 4.A.2.  CONVOY DISRUPTION PARADOXES
# a: Convoyed armies don't cut support to fleets attacking its convoy fleet.
# b: Convoyed armies don't cut support to or against any convoying fleet.
# c: Convoyed armies don't cut support to fleets necessary for the convoy.
# d: Convoyed armies in a paradoxical situation don't move.
# e: All moves in a paradoxical situation fail.
# f: All convoys fail if consistent; otherwise, all moves fail.
# DATC: d; DPTG: f; DAIDE: f
;datc_4a2 = d

# convoying to adjacent place (character)
# 4.A.3.  CONVOYING TO ADJACENT PLACE
# a: Always choose the convoy route.
# b: Choose the land route except in head-to-head situations.
# c: Choose the land route except in head-to-head with undisrupted route.
# d: Determine the intent from the player's order set.
# e: Use the land route unless specifically ordered to be convoyed.
# f: Never convoy unless specifically ordered.
# DATC: d(c); DPTG: e; DAIDE: f
;datc_4a3 = f

# support cut on attack on itself via convoy (character)
# 4.A.4.  SUPPORT CUT ON ATTACK ON ITSELF VIA CONVOY
# a: Support is not cut.
# b: Support is cut.
# DATC: a; DPTG: b; DAIDE: b
;datc_4a4 = a

# retreat when dislodged by convoy (character)
# 4.A.5.  RETREAT WHEN DISLODGED BY CONVOY
# a: Dislodged units may not retreat to the starting place of any attacker.
# b: Dislodged units may retreat to the starting place of a convoyed attacker.
# DATC: b; DPTG: b; DAIDE: a
;datc_4a5 = b

# convoy path specification (character)
# 4.A.6.  CONVOY PATH SPECIFICATION
# a: Path specifications are ignored.
# b: Path specifications are allowed, but not required.
# c: Path specifications are required.
# DATC: a(b); DPTG: a; DAIDE: c
;datc_4a6 = b

# avoiding a head to head battle to bounce a unit (character)
# 4.A.7.  AVOIDING A HEAD TO HEAD BATTLE TO BOUNCE A UNIT
# a: Dislodged units never have effect on attacker's space.
# b: Dislodged units have no effect on attacker's space in head-to-head combat.
# DATC: b; DPTG: b; DAIDE: b
;datc_4a7 = b

# omitted coast specification in move order when two coasts are possible (character)
# 4.B.1.  OMITTED COAST SPECIFICATION IN MOVE ORDER WHEN TWO COASTS ARE POSSIBLE
# a: Such a move fails.
# b: A move is attempted to a default coast.
# DATC: a; DPTG: a; DAIDE: a
;datc_4b1 = a

# omitted coast specification in move order when one coast is possible (character)
# 4.B.2.  OMITTED COAST SPECIFICATION IN MOVE ORDER WHEN ONE COAST IS POSSIBLE
# a: A move is attempted to the only possible coast.
# b: A move is attempted to a default coast.
# c: The move fails.
# DATC: a; DPTG: a; DAIDE: c
;datc_4b2 = c

# move order to impossible coast (character)
# 4.B.3.  MOVE ORDER TO IMPOSSIBLE COAST
# a: A move is attempted to the only possible coast.
# b: The move fails.
# DATC: b; DPTG: ?; DAIDE: b
;datc_4b3 = b

# coast specification in support order (character)
# 4.B.4.  COAST SPECIFICATION IN SUPPORT ORDER
# a: Missing coast in a support order fails.
# b: Missing coast in a support order goes to a default coast.
# c: Missing coast in a support order fails unless unambiguous.
# d: Support to a specific coast is allowed, but not required.
# e: Support to a specific coast is not allowed.
# DATC: d; DPTG: e; DAIDE: e
;datc_4b4 = d

# wrong coast of ordered unit (character)
# 4.B.5.  WRONG COAST OF ORDERED UNIT
# a: The move fails.
# b: Coast specification is ignored.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4b5 = a

# unknown coasts or irrelevant coasts (character)
# 4.B.6.  UNKNOWN COASTS OR IRRELEVANT COASTS
# a: The move fails.
# b: Coast specification is ignored.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4b6 = a

# coast specification in build order (character)
# 4.B.7.  COAST SPECIFICATION IN BUILD ORDER
# a: A fleet build fails if it does not specify a coast when necessary.
# b: The fleet is built on a default coast.
# DATC: a; DPTG: ?; DAIDE: a
;datc_4b7 = a

# missing unit designation (character)
# 4.C.1.  MISSING UNIT DESIGNATION
# a: The order is invalid.
# b: The order is valid.
# c: The order is valid unless a correct order exists.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4c1 = b

# wrong unit designation (character)
# 4.C.2.  WRONG UNIT DESIGNATION
# a: The order is invalid.
# b: The order is valid.
# c: The order is valid unless a correct order exists.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4c2 = a

# missing unit designation in build order (character)
# 4.C.3.  MISSING UNIT DESIGNATION IN BUILD ORDER
# a: The build always fails.
# b: The build fails in coastal areas, but succeeds when unambiguous.
# c: Armies are built inland, fleets when a specific coast is specified.
# DATC: c; DPTG: ?; DAIDE: a
;datc_4c3 = b

# building a fleet in a land area (character)
# 4.C.4.  BUILDING A FLEET IN A LAND AREA
# a: The build always fails.
# b: An army us built instead.
# DATC: a; DPTG: ?; DAIDE: a
;datc_4c4 = a

# missing nationality in support order (character)
# 4.C.5.  MISSING NATIONALITY IN SUPPORT ORDER
# a: The order is invalid.
# b: The order is valid.
# c: The order is valid unless another order uses the correct nationality.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4c5 = b

# wrong nationality in support order (character)
# 4.C.6.  WRONG NATIONALITY IN SUPPORT ORDER
# a: The order is invalid.
# b: The order is valid.
# c: The order is valid unless another order uses the correct nationality.
# DATC: b; DPTG: ?; DAIDE: a
;datc_4c6 = a

# multiple order sets with defined order (character)
# 4.D.1.  MULTIPLE ORDER SETS WITH DEFINED ORDER
# a: All order sets are combined to one set of orders.
# b: All order sets are combined, unless latest clearly replaces all earlier.
# c: Only the latest order set is considered, unless otherwise specified.
# d: Only the latest order set is considered.
# DATC: c; DPTG: ?; DAIDE: b
;datc_4d1 = b

# multiple order sets with undefined order (character)
# 4.D.2.  MULTIPLE ORDER SETS WITH UNDEFINED ORDER
# a: All units hold.
# b: All order sets are combined.
# c: Order sets must have a defined order.
# DATC: b; DPTG: ?; DAIDE: c
;datc_4d2 = c

# multiple orders to the same unit (character)
# 4.D.3.  MULTIPLE ORDERS TO THE SAME UNIT
# a: The first order in a set is used.
# b: The last order in a set is used.
# c: The orders are illegal (the unit holds).
# DATC: c; DPTG: ?; DAIDE: b
;datc_4d3 = b

# too many build orders (character)
# 4.D.4.  TOO MANY BUILD ORDERS
# a: All build orders are invalid.
# b: The first legal build orders are used.
# c: The last legal build orders are used.
# DATC: b; DPTG: ?; DAIDE: b
;datc_4d4 = b

# multiple build orders for one area (character)
# 4.D.5.  MULTIPLE BUILD ORDERS FOR ONE AREA
# a: Both build orders fail.
# b: The first build order is used.
# c: The last build order is used.
# DATC: b; DPTG: ?; DAIDE: c
;datc_4d5 = c

# too many disband orders (character)
# 4.D.6.  TOO MANY DISBAND ORDERS
# a: All disbands are handled by civil disorder rules.
# b: The first legal disband orders are used.
# c: The last legal disband orders are used.
# DATC: b; DPTG: ?; DAIDE: b
;datc_4d6 = b

# waiving builds (character)
# 4.D.7.  WAIVING BUILDS
# a: Waiving builds is allowed.
# b: Waiving builds is not allowed.
# DATC: a; DPTG: ?; DAIDE: a
;datc_4d7 = a

# removing a unit in civil disorder (character)
# 4.D.8.  REMOVING A UNIT IN CIVIL DISORDER
# a: Convoys count as one move; no fleet necessary.
# b: Convoys count as one move, but require fleets of the same nation.
# c: Convoys count as one move, but require fleets of any nation.
# d: Armies may move as a fleet.
# e: Armies may move as a fleet, and fleets may move as an army.
# f: The oldest unit not at a supply center is removed.
# DATC: d; DPTG: d; DAIDE: ?
;datc_4d8 = e

# receiving hold support in civil disorder (character)
# 4.D.9.  RECEIVING HOLD SUPPORT IN CIVIL DISORDER
# a: Units in civil disorder cannot receive support.
# b: Units in civil disorder can receive support.
# DATC: b; DPTG: ?; DAIDE: ?
;datc_4d9 = b

# illegal orders (character)
# 4.E.1.  ILLEGAL ORDERS
# a: Every order with the right format is legal.
# b: Legal orders may only use places on the map.
# c: Only orders that can be valid in a game situation are legal.
# d: Only orders that can be valid in the current game situation are legal.
# DATC: d; DPTG: a; DAIDE: d
;datc_4e1 = d

# poorly written orders (character)
# 4.E.2.  POORLY WRITTEN ORDERS
# a: No knowledge of Diplomacy must be used to correct orders.
# b: Each order may be corrected to make it legal.
# c: Other orders in the set may be considered when correcting an order.
# d: Orders may be corrected to match other orders within the set.
# e: Orders may not be corrected.
# DATC: d; DPTG: ?; DAIDE: e
;datc_4e2 = e

# implicit orders (character)
# 4.E.3.  IMPLICIT ORDERS
# a: Implicit orders are allowed.
# b: Implicit orders are not allowed.
# DATC: b; DPTG: ?; DAIDE: b
;datc_4e3 = b

# perpetual orders (character)
# 4.E.4.  PERPETUAL ORDERS
# a: Perpetual orders are allowed.
# b: Perpetual orders are not allowed.
# DATC: b; DPTG: ?; DAIDE: b
;datc_4e4 = b

# proxy orders (character)
# 4.E.5.  PROXY ORDERS
# a: Proxy orders are allowed, with prior notification to the judge.
# b: Proxy orders are allowed as part of the normal order set.
# c: Proxy orders are not allowed.
# DATC: c; DPTG: ?; DAIDE: c
;datc_4e5 = c

# flying dutchman (character)
# 4.E.6.  FLYING DUTCHMAN
# a: Allowed, as long as it is a deception.
# DATC: a; DPTG: ?; DAIDE: ?
;datc_4e6 = a


[tokens]
# Minor options for dealing with token conversion.

# squeeze parentheses (boolean)
# Whether to omit the spaces just inside parentheses when printing messages.
;squeeze_parens = no

# ignore unknown tokens (boolean)
# Whether to allow tokens not represented in the protocol document or RM.
# If this is false, unknown tokens in a DM will result in an Error Message.
;ignore_unknown = yes

# input escape character (character)
# The character which escapes quotation marks when translating messages.
# This can be the same as the quotation mark character itself.
;input_escape = \

# output escape character (character)
# The character with which to escape quotation marks when printing messages.
# This can be the same as the quotation mark character itself.
;output_escape = \

# quotation mark (character)
# The character to use for quoting strings when printing messages.
;quot_char = "


[syntax]
# Syntax files and special tokens.
# Note: File names are relative to the current working directory,
#       *not* the directory of this file.

# variants file (file)
# Document listing the available map variants, with their names and files.
;variant_file = docs/variants.html

# move phases (list)
# Tokens that indicate movement phases
;move_phases = SPR, FAL

# retreat phases (list)
# Tokens that indicate retreat phases
;retreat_phases = SUM, AUT

# build phases (list)
# Tokens that indicate build phases
;build_phases = WIN

# move order mask (integer)
# Bit that indicates movement phase in order token numbers.
;move_phase_bit = 0x20

# retreat order mask (integer)
# Bit that indicates retreat phase in order token numbers.
;retreat_phase_bit = 0x40

# build order mask (integer)
# Bit that indicates build phase in order token numbers.
;build_phase_bit = 0x80

# protocol file (file)
# Document specifying protocol information, including token names and numbers.
;dcsp_file = docs/protocol.html

# syntax file (file)
# Document specifying syntax rules and level names.
;syntax_file = docs/syntax.html
